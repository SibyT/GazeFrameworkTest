package gaze_selection_library;

import gaze_library.DummyGazeProvider;
import gaze_library.FilteredDataProvider;
import gaze_library.GP3GazePoint;
import gaze_library.GazeDataProvider;
import gaze_library.GazePoint;
import gaze_library.GazePointEvent;
import gaze_library.GazePointListener;
import gaze_library.SimpleGazePoint;
import gaze_library.TheEyeTribeGazePoint;
import gaze_library.Validity;

import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.logging.Level;

import javax.imageio.ImageIO;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JRadioButton;
import javax.swing.JScrollBar;
import javax.swing.JSlider;
import javax.swing.JSpinner;
import javax.swing.JToggleButton;

import org.jdom2.Element;

/**
 * @author Thorsten Bövers
 * This class provides a default implementation of the abstract methods of the GazeTarget class.
 * It represents a basic JPanel with some buttons as target items. The number of target items and some other
 * properties can be set within the constructor.
 * From the owner of the object of this class the intended target item is selected by the setTargetIndex method.
 * After the selection is performed, the owner will be notified by the recordingDataInGazeTargetFinished method.
 */
public class BasicGazeTarget extends GazeTarget implements GazePointListener, SelectionTriggerMechanismListener {

	private static final long serialVersionUID = 4018966808764793017L;

	/**
	 * Variable for the feedBackCursor.
	 */
	protected boolean feedBackCursor = true;

	/**
	 * Variable for the number of targetItems.
	 */
	protected int numberOfTargetItems = 6;

	/**
	 * Variable for the relational size of the targetItems.
	 */
	protected int buttonHeightRatio = 15;

	/**
	 * Variable for the relational empty space between the targetItems on the screen.
	 */
	protected int deadSpace = 10;

	/**
	 * Stores a reference to the SelectionTriggerType. This variable is initialized with the KeyboardTriggerMechanism.
	 */
	protected SelectionTriggerType selectionTriggerType = SelectionTriggerType.KeyboardKeyC;

	/**
	 * Variable for the dwelltime in milliseconds. Recommended value: one second = 1000.
	 */
	protected int dwellTimeInMilliseconds = 1000;

	/**
	 * Variable is a upper bound for the variance of all valid gaze points for the given dwell time.
	 * Only if the variance is under this value, a TriggerEvent will be generated by the DwellTimeTriggerMechanism.
	 * Recommended value: 400.
	 */
	protected int dwellTimeAccuracy = 400;

	/**
	 * Variable for the lower bound for the wink time. Only if one eyelid is closed for at least this value in milliseconds,
	 * a TriggerEvent will be generated by the WinkTriggerMechanism.
	 * Recommended value: 300 milliseconds.
	 */
	protected int winkTimeInMilliseconds = 300;

	/**
	 * Queue for storing received GazePoints from the rawGazeDataProvider for the last 5 seconds.
	 */
	protected ConcurrentLinkedDeque<GazePoint> _rawGazePoints = new ConcurrentLinkedDeque<GazePoint>();

	/**
	 * Queue for storing received GazePoints from the filteredGazeDataProvider for the last 5 seconds.
	 */
	protected ConcurrentLinkedDeque<GazePoint> _filteredGazePoints = new ConcurrentLinkedDeque<GazePoint>();

	/**
	 * This variable stores a reference to the GazeDataFuture object which stores future GazePoints from the rawGazeDataProvider.
	 */
	protected GazeDataFuture rawGazeDataFuture = null;

	/**
	 * This variable stores a reference to the GazeDataFuture object which stores future GazePoints from the filteredGazeDataProvider.
	 */
	protected GazeDataFuture filteredGazeDataFuture = null;

	/**
	 * Gives the number of GazePoints which are used to compute the recent location if a TriggerEvent happened.
	 */
	protected int numberOfGazePointsForRecentLocationComputation = 60;

	/**
	 * Gives the minimum number of future GazePoints until a screenShot is taken.
	 */
	protected int minimumNumberForFutureGazePoints = 10;

	/**
	 * Gives the maximum number of future GazePoints which will be painted on the screenshot.
	 */
	protected int maximumNumberForFutureGazePoints = 1000;

	/**
	 * This variable stores the filtered location of the GazePoints which are used to indicate the trigger position.
	 */
	protected Point recentLocation = new Point();

	/**
	 * This list stores all valid GazePoints which were used to compute the recent location.
	 */
	protected LinkedList<GazePoint> _validGPbeforeTrigger = new LinkedList<GazePoint>();	

	/**
	 * If this flag is set, future GazePoints were recorded. This requires more time after the TriggerEvent because the takeScreenshot method waits
	 * until the minimumNumberForFutureGazePoints is reached.
	 */
	protected boolean storeFutureGazeData = true;

	/**
	 * This list stores the targetItems. In this implementation JButtons.
	 */
	protected LinkedList<JButton> _targetItems = new LinkedList<JButton>();
	protected LinkedList<JCheckBox> _targetItems_chk = new LinkedList<JCheckBox>();
	protected LinkedList<JRadioButton> _targetItems_rad = new LinkedList<JRadioButton>();
	protected LinkedList<JToggleButton> _targetItems_toggle = new LinkedList<JToggleButton>();
	



	/**
	 * Variable for the index of the intended targetItem which has to be selected.
	 */
	protected int intendedTargetItemIndex;

	/**
	 * Variable for the index of the selected targetItem.
	 */
	protected int selectedTargetItemIndex;
	
	/**
	 * Variable which stores the last target on which the feedback cursor was over
	 */
	protected int lastTargetIndex = -1;

	/**
	 * This variable stores the background color of the unselected targetItem.
	 */
	protected Color targetItemColor = Color.WHITE;

	/**
	 * This variable stores the color of the selected targetItem.
	 */
	protected Color targetItemSelectedColor = Color.BLUE;

	/**
	 * Variable for the number of selected test runs. Value is increased after a selection. Is used for the recordData method.
	 */
	protected int targetIndexCounter = 0;
	protected String type = null;


	/**
	 * Variable represents the start time in milliseconds of a presented test run.
	 * It is set when the intended targetItem is marked.
	 */
	protected long timeStart;

	/**
	 * Variable represents the end time in milliseconds of a presented test run.
	 * It is set when the TriggerEvent was generated.
	 */
	protected long timeEnd;

	/**
	 * Stores the time needed for trigger a targetItem in milliseconds.
	 */
	protected long timeDuration;

	/**
	 * Variable represents the start time in CPU time ticks of a presented test run.
	 * It is set when the intended targetItem is marked.
	 */
	protected long timeTickStart;

	/**
	 * Variable represents the end time in CPU time ticks of a presented test run.
	 * It is set when the TriggerEvent was generated.
	 */
	protected long timeTickTriggered;

	/**
	 * Variable stores the last stored GazePoint to unmark it on the jPanel
	 */
	protected Point lastGazePointLocation = null;

	/**
	 * Variable stores a reference to the SelectionTriggerMechanism.
	 */
	protected SelectionTriggerMechanism selectionTriggerMechanism;

	/**
	 * Thread which processes the selection sequence.
	 * Therefore another thread is used to speed up the system.
	 */
	protected Thread triggerThread;

	/**
	 * Thread which processes new received GazePointEvents.
	 * Therefore another thread is used to speed up the system.
	 */
	protected Thread gazePointReceivedThread;

	/**
	 * Queue which stores new GazePointEvents. They are processed by the gazePointReceivedThread.
	 */
	protected ConcurrentLinkedDeque<GazePointEvent> concurrentGPEQueue = new ConcurrentLinkedDeque<GazePointEvent>();

	/**
	 * This XML element stores the recorded data for one TestPlanItem.
	 */
	protected Element recordedData = null;
	protected boolean frmsngtest = false;


	/**
	 * Standard constructor which initialized the BasicGazeTarget with standard values.
	 * @param testManager as BasicGazeTarget owner
	 * @param rawGazeDataProvider
	 * @param filteredDataProvider
	 */
	public BasicGazeTarget(TestManager testManager, GazeDataProvider rawGazeDataProvider, FilteredDataProvider filteredDataProvider) {
		super(testManager, rawGazeDataProvider, filteredDataProvider);
		// BasicGazeTarget is initialized with the given standard values		
		initGazeTarget();
	}

	/**
	 * Constructor which initialized the BasicGazeTarget with the values given in the basicGazeTargetTypeProperties list.
	 * @param testManager as BasicGazeTarget owner
	 * @param rawGazeDataProvider
	 * @param filteredDataProvider
	 * @param basicGazeTargetTypeProperties stores the concrete property values
	 */
	public BasicGazeTarget(TestManager testManager, GazeDataProvider rawGazeDataProvider, FilteredDataProvider filteredDataProvider, LinkedList<String> basicGazeTargetTypeProperties) {
		super(testManager, rawGazeDataProvider, filteredDataProvider);

		// read in the given properties for the BasicGazeTarget
		if (Integer.valueOf(basicGazeTargetTypeProperties.get(0)) == 1) {
			this.feedBackCursor = true;
		} else {
			this.feedBackCursor = false;
		}
		this.numberOfTargetItems = Integer.valueOf(basicGazeTargetTypeProperties.get(1));
		this.buttonHeightRatio = Integer.valueOf(basicGazeTargetTypeProperties.get(2));
		this.deadSpace = Integer.valueOf(basicGazeTargetTypeProperties.get(3));
		switch (basicGazeTargetTypeProperties.get(4)) {
		case "KeyboardKeyC":
			this.selectionTriggerType = SelectionTriggerType.KeyboardKeyC;
			break;
		case "DwellTime":
			this.selectionTriggerType = SelectionTriggerType.DwellTime;
			this.dwellTimeInMilliseconds = Integer.valueOf(basicGazeTargetTypeProperties.get(5));
			this.dwellTimeAccuracy = Integer.valueOf(basicGazeTargetTypeProperties.get(6));
			break;
		case "Wink":
			this.selectionTriggerType = SelectionTriggerType.Wink;
			this.winkTimeInMilliseconds = Integer.valueOf(basicGazeTargetTypeProperties.get(5));
			break;
		case "Speech":
			this.selectionTriggerType = SelectionTriggerType.Speech;
			break;
		}

		initGazeTarget();
	}
//siby
	public BasicGazeTarget(TestManager testManager,
			GazeDataProvider rawGazeDataProvider,
			FilteredDataProvider filteredDataProvider,
			TestPlanItem currentTestPlanItem) {
		super(testManager, rawGazeDataProvider, filteredDataProvider);
		frmsngtest=true;
		LinkedList<String> basicGazeTargetTypeProperties= currentTestPlanItem.getTargetSelectionTypeProperties();
		this.type=currentTestPlanItem.getType();
		// read in the given properties for the BasicGazeTarget
		if (Integer.valueOf(basicGazeTargetTypeProperties.get(0)) == 1) {
			this.feedBackCursor = true;
		} else {
			this.feedBackCursor = false;
		}
		this.numberOfTargetItems = Integer.valueOf(basicGazeTargetTypeProperties.get(1));
		this.buttonHeightRatio = Integer.valueOf(basicGazeTargetTypeProperties.get(2));
		this.deadSpace = Integer.valueOf(basicGazeTargetTypeProperties.get(3));
		switch (basicGazeTargetTypeProperties.get(4)) {
		case "KeyboardKeyC":
			this.selectionTriggerType = SelectionTriggerType.KeyboardKeyC;
			break;
		case "DwellTime":
			this.selectionTriggerType = SelectionTriggerType.DwellTime;
			this.dwellTimeInMilliseconds = Integer.valueOf(basicGazeTargetTypeProperties.get(5));
			this.dwellTimeAccuracy = Integer.valueOf(basicGazeTargetTypeProperties.get(6));
			break;
		case "Wink":
			this.selectionTriggerType = SelectionTriggerType.Wink;
			this.winkTimeInMilliseconds = Integer.valueOf(basicGazeTargetTypeProperties.get(5));
			break;
		case "Speech":
			this.selectionTriggerType = SelectionTriggerType.Speech;
			break;
		}

		initGazeTarget();
	}

	/**
	 * This method initializes the BasicGazeTarget. It registers the SelectionTriggerMechanism and starts Threads for concurrency.
	 */
	protected void initGazeTarget() {
		if (type!=null&& type.equalsIgnoreCase("Toggle")){
		inittoggleJPanel();
		}else if (type!=null&& type.equalsIgnoreCase("Radio")){
			initradioJPanel();
		}else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
			initchkboxJPanel();
		}else{
		initJPanel();
		}
		// is needed to handle simulated wink trigger with a clicked mouse
		if ((rawGazeDataProvider instanceof DummyGazeProvider) && rawGazeDataProvider != null) {				
			this.addMouseListener((DummyGazeProvider) rawGazeDataProvider);
		} else if ((filteredDataProvider instanceof DummyGazeProvider) && filteredDataProvider != null) {
			this.addMouseListener((DummyGazeProvider) filteredDataProvider);
		}

		// create the SelectionTriggerMechanism
		switch (selectionTriggerType.toString()) {
		case "KeyboardKeyC":
			selectionTriggerMechanism = new KeyboardTriggerMechanism(this);
			break;
		case "DwellTime":
			if (rawGazeDataProvider!=null) {
				selectionTriggerMechanism = new DwellTimeTriggerMechanism(rawGazeDataProvider,dwellTimeInMilliseconds,trackerFrequency,dwellTimeAccuracy);
			} else if (filteredDataProvider!=null){
				selectionTriggerMechanism = new DwellTimeTriggerMechanism(filteredDataProvider,dwellTimeInMilliseconds,trackerFrequency,dwellTimeAccuracy);
			}				
			break;
		case "Wink":
			if (rawGazeDataProvider!=null) {
				selectionTriggerMechanism = new WinkTriggerMechanism(rawGazeDataProvider,winkTimeInMilliseconds);
			} else if (filteredDataProvider!=null){
				selectionTriggerMechanism = new WinkTriggerMechanism(filteredDataProvider,winkTimeInMilliseconds);
			}
			break;
		case "Speech":
			selectionTriggerMechanism = new SpeechTriggerMechanism();
			break;
		}		
		log.info(System.currentTimeMillis() + " - " + "Created SelectionTriggerMechanism " + selectionTriggerType.toString());

		// create a new thread which is responsible for the TriggerEvents
		triggerThread = new Thread() {
			@Override
			public void run() {
				while (true) {
					synchronized (this) {					
						try {
							wait();
						} catch (InterruptedException e) {
							log.log(Level.SEVERE,null, e);
						}
						selectionTriggered();
					}
				}
			}
		};
		triggerThread.start();

		// initialize FutureGazeReaders if the storeFutureGazeData flag is set
		if (storeFutureGazeData) {			
			if (rawGazeDataProvider != null) {
				rawGazeDataFuture = new FutureGazeReader(rawGazeDataProvider,BasicGazeTarget.this);
			}
			if (filteredDataProvider != null) {
				filteredGazeDataFuture = new FutureGazeReader(filteredDataProvider,BasicGazeTarget.this);
			}					
		}

		// create a new thread which is responsible for processing the received GazePoints
		gazePointReceivedThread = new Thread() {
			@Override
			public void run() {
				while (true) {
					synchronized (this) {
						try {
							wait();
						} catch (InterruptedException e) {
							log.log(Level.SEVERE,null, e);
						}
						while (!concurrentGPEQueue.isEmpty()) {
							processReceivedGazePointEvent(concurrentGPEQueue.remove());
						}
					}
				}
			}
		};
		gazePointReceivedThread.start();
		this.setFocusable(true);
	}
	private void initscrollJPanel() {
		// TODO Auto-generated method stub
		
	}

	private void inittoggleJPanel() {
		// TODO Auto-generated method stub

		// TODO Auto-generated method stub

		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));		

		for (int i=1; i<=numberOfTargetItems; i++) {
			// add some empty space between the buttons
		
			this.add(Box.createRigidArea(new Dimension(0,deadSpace)));
			JToggleButton button=new JToggleButton("Toggle "+i);
			button.setSize(deadSpace, buttonHeightRatio);
			button.setFocusable(false);
			button.setRolloverEnabled(false);
			button.setBackground(targetItemColor);
			_targetItems_toggle.addLast(button);
			//button.setMaximumSize(new Dimension(buttonHeightRatio, 2*buttonHeightRatio));
			button.setAlignmentX(Component.CENTER_ALIGNMENT);
			// to handle simulated wink trigger with a clicked mouse also if mouse is on a button
			if (rawGazeDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) rawGazeDataProvider);
			} else if (filteredDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) filteredDataProvider);
			}
			this.add(button);			
		}
	
		
	
		
	}

	private void initradioJPanel() {
		// TODO Auto-generated method stub

		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));		

		for (int i=1; i<=numberOfTargetItems; i++) {
			// add some empty space between the buttons
		
			this.add(Box.createRigidArea(new Dimension(0,deadSpace)));
			JRadioButton button=new JRadioButton("radio "+i);
			button.setSize(deadSpace, buttonHeightRatio);
			button.setFocusable(false);
			button.setRolloverEnabled(false);
			button.setBackground(targetItemColor);
			_targetItems_rad.addLast(button);
			//button.setMaximumSize(new Dimension(buttonHeightRatio, 2*buttonHeightRatio));
			button.setAlignmentX(Component.CENTER_ALIGNMENT);
			// to handle simulated wink trigger with a clicked mouse also if mouse is on a button
			if (rawGazeDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) rawGazeDataProvider);
			} else if (filteredDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) filteredDataProvider);
			}
			this.add(button);			
		}
	
		
	}

	//siby
	private void initchkboxJPanel() {
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));		
		
		for (int i=1; i<=numberOfTargetItems; i++) {
			// add some empty space between the buttons
			
			this.add(Box.createRigidArea(new Dimension(0,deadSpace)));
			//JCheckBox jchk=new JCheckBox("Checkbox "+i);
			//jchk.setSize(buttonHeightRatio, deadSpace);
			JCheckBox button = new JCheckBox("Checkbox "+i);
			button.setBounds(288, 98, deadSpace, buttonHeightRatio);

			//button.add(jchk);
			button.setFocusable(false);
			button.setRolloverEnabled(false);
			button.setBackground(targetItemColor);
			_targetItems_chk.addLast(button);
			//button.setMaximumSize(new Dimension(7*buttonHeightRatio, 2*buttonHeightRatio));
			button.setAlignmentX(Component.CENTER_ALIGNMENT);
			// to handle simulated wink trigger with a clicked mouse also if mouse is on a button
			if (rawGazeDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) rawGazeDataProvider);
			} else if (filteredDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) filteredDataProvider);
			}
			this.add(button);			
		}
	}

	/**
	 * This method creates the targetItems on the BasicGazTarget panel.
	 */
	protected void initJPanel() {
		this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));		

		for (int i=1; i<=numberOfTargetItems; i++) {
			// add some empty space between the buttons
			this.add(Box.createRigidArea(new Dimension(0,deadSpace)));
			JButton button = new JButton("Button "+i);
			button.setFocusable(false);
			button.setRolloverEnabled(false);
			button.setBackground(targetItemColor);
			_targetItems.addLast(button);
			button.setMaximumSize(new Dimension(7*buttonHeightRatio, 2*buttonHeightRatio));
			button.setAlignmentX(Component.CENTER_ALIGNMENT);
			// to handle simulated wink trigger with a clicked mouse also if mouse is on a button
			if (rawGazeDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) rawGazeDataProvider);
			} else if (filteredDataProvider instanceof DummyGazeProvider) {
				button.addMouseListener((DummyGazeProvider) filteredDataProvider);
			}
			this.add(button);			
		}
	}

	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#selectionTriggered()
	 */
	@Override
	protected void selectionTriggered() {
		// end recording time
		timeEnd = System.currentTimeMillis();
		timeTickTriggered = System.nanoTime();
		log.info(System.currentTimeMillis() + " - " + "Stopped recording time");
		
		// remove visual feedback at this point
		if (lastTargetIndex != -1) {
			if (type!=null&& type.equalsIgnoreCase("Radio")){
				_targetItems_rad.get(lastTargetIndex).setSelected(false);
			}
			else if (type!=null&& type.equalsIgnoreCase("Toggle")){
				_targetItems_toggle.get(lastTargetIndex).setSelected(false);
			}
			else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
				_targetItems_chk.get(lastTargetIndex).setSelected(false);
			}else{
			_targetItems.get(lastTargetIndex).setSelected(false);
				}
			lastTargetIndex = -1;
		}

		// remove this GazePointListener from the GazeDataProvider
		if (rawGazeDataProvider!=null) { 
			rawGazeDataProvider.removeGazePointListener(this);
		}
		if (filteredDataProvider!=null) { 
			filteredDataProvider.removeGazePointListener(this);
		}
		log.info(System.currentTimeMillis() + " - " + "Removed GazeTargetPanel as GazePointListener from the GazeDataProvider");

		// remove this SelectionTriggerMechanismListener from the SelectionTriggerMechanism		
		selectionTriggerMechanism.removeSelectionTriggerMechanismListener(this);
		log.info(System.currentTimeMillis() + " - " + "Removed GazeTargetPanel as SelectionTriggerMechanismListener from the SelectionTriggerMechanism");

		// compute recent location of the last gazePoints
		computeRecentLocation();

		resolveSelection(recentLocation, _rawGazePoints, _filteredGazePoints, rawGazeDataFuture, filteredGazeDataFuture);
	}

	/**
	 * This method computes the recent location depending on the latest GazePoints after a TriggerEvent was generated.
	 * For the computation only the latest numberOfGazePointsForRecentLocationComputation are used.
	 */
	protected void computeRecentLocation() {
		// check if GazePoints were recorded
		if (!_rawGazePoints.isEmpty()) {
			Iterator<GazePoint> iter = _rawGazePoints.iterator();
			// set initial values out of the panel to avoid clicks on buttons
			recentLocation.x = -1;
			recentLocation.y = -1;
			_validGPbeforeTrigger.clear();
			for (int i=0; i<numberOfGazePointsForRecentLocationComputation && iter.hasNext(); i++) {
				GazePoint current = iter.next();
				// filter GazePoints which are invalid or partially valid or located outside this panel
				if (current.getLocation().x > 0 && current.getLocation().x <= this.getWidth() && current.getLocation().y > 0 && current.getLocation().y <= this.getHeight() && current.getValidity().equals(Validity.VALID)) {
					recentLocation.x += current.getLocation().x;
					recentLocation.y += current.getLocation().y;
					_validGPbeforeTrigger.add(current);
				}
			}
			if (!_validGPbeforeTrigger.isEmpty()) {
				recentLocation.x /= _validGPbeforeTrigger.size();
				recentLocation.y /= _validGPbeforeTrigger.size();
			}
		} else if (!_filteredGazePoints.isEmpty()) {
			Iterator<GazePoint> iter = _filteredGazePoints.iterator();
			recentLocation.x = -1;
			recentLocation.y = -1;
			_validGPbeforeTrigger.clear();
			for (int i=0; i<numberOfGazePointsForRecentLocationComputation && iter.hasNext(); i++) {
				GazePoint current = iter.next();
				// filter GazePoints which are invalid or partially valid or located outside this panel
				if (current.getLocation().x > 0 && current.getLocation().x <= this.getWidth() && current.getLocation().y > 0 && current.getLocation().y <= this.getHeight() && current.getValidity().equals(Validity.VALID)) {
					recentLocation.x += current.getLocation().x;
					recentLocation.y += current.getLocation().y;
					_validGPbeforeTrigger.add(current);
				}
			}
			if (!_validGPbeforeTrigger.isEmpty()) {
				recentLocation.x /= _validGPbeforeTrigger.size();
				recentLocation.y /= _validGPbeforeTrigger.size();
			}
		}
		log.info(System.currentTimeMillis() + " - " + "Computed recent location of the last " + numberOfGazePointsForRecentLocationComputation + " GazePoints");
	}

	/*
	 * (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#resolveSelection(java.awt.Point, java.util.concurrent.ConcurrentLinkedDeque, java.util.concurrent.ConcurrentLinkedDeque, gaze_selection_library.GazeDataFuture, gaze_selection_library.GazeDataFuture)
	 */
	@Override
	protected void resolveSelection(Point recentLocation, ConcurrentLinkedDeque<GazePoint> rawGPs, ConcurrentLinkedDeque<GazePoint> filteredGPs, GazeDataFuture rawGazeDataFuture, GazeDataFuture filteredGazeDataFuture) {
		if (type!=null&& type.equalsIgnoreCase("Radio")){
			Iterator<JRadioButton> iter_rad=_targetItems_rad.iterator();
			selectedTargetItemIndex = -1;
			for (int i=0; iter_rad.hasNext(); i++) {
				JToggleButton current = iter_rad.next();
				if (recentLocation.x >= current.getLocation().x && recentLocation.x <= current.getLocation().x + current.getWidth() && recentLocation.y >= current.getLocation().y && recentLocation.y <= current.getLocation().y + current.getHeight()) {
					selectedTargetItemIndex = i;
					log.info(System.currentTimeMillis() + " - " + "Found selected TargetItem");
					break;
				}
			}

		}
		else if (type!=null&& type.equalsIgnoreCase("Toggle")){
			Iterator<JToggleButton> iter_togg=_targetItems_toggle.iterator();
			selectedTargetItemIndex = -1;
			for (int i=0; iter_togg.hasNext(); i++) {
				JToggleButton current = iter_togg.next();
				if (recentLocation.x >= current.getLocation().x && recentLocation.x <= current.getLocation().x + current.getWidth() && recentLocation.y >= current.getLocation().y && recentLocation.y <= current.getLocation().y + current.getHeight()) {
					selectedTargetItemIndex = i;
					log.info(System.currentTimeMillis() + " - " + "Found selected TargetItem");
					break;
				}
			}

		}
		else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
			Iterator<JCheckBox> iter_chk=_targetItems_chk.iterator();
			selectedTargetItemIndex = -1;
			for (int i=0; iter_chk.hasNext(); i++) {
				JCheckBox current = iter_chk.next();
				if (recentLocation.x >= current.getLocation().x && recentLocation.x <= current.getLocation().x + current.getWidth() && recentLocation.y >= current.getLocation().y && recentLocation.y <= current.getLocation().y + current.getHeight()) {
					selectedTargetItemIndex = i;
					log.info(System.currentTimeMillis() + " - " + "Found selected TargetItem");
					break;
				}
			}

		}else{
		Iterator<JButton> iter = _targetItems.iterator();
		selectedTargetItemIndex = -1;
		for (int i=0; iter.hasNext(); i++) {
			JButton current = iter.next();
			if (recentLocation.x >= current.getLocation().x && recentLocation.x <= current.getLocation().x + current.getWidth() && recentLocation.y >= current.getLocation().y && recentLocation.y <= current.getLocation().y + current.getHeight()) {
				selectedTargetItemIndex = i;
				log.info(System.currentTimeMillis() + " - " + "Found selected TargetItem");
				break;
			}
		}

			}
		
		// Perform a visual click on the targetItem if a targetItem was triggered
		if (selectedTargetItemIndex != -1) {
			if (type!=null&& type.equalsIgnoreCase("Radio")){
				doSelection(_targetItems_rad.get(selectedTargetItemIndex));
			}
			else if (type!=null&& type.equalsIgnoreCase("Toggle")){
				doSelection(_targetItems_toggle.get(selectedTargetItemIndex));
			}
			else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
				doSelection(_targetItems_chk.get(selectedTargetItemIndex));

			}
			else{
			doSelection(_targetItems.get(selectedTargetItemIndex));
			}
			log.info(System.currentTimeMillis() + " - " + "Performed visual click on selected TargetItem");
		}

		log.info(System.currentTimeMillis() + " - " + "Start to take screenshots");
		takeScreenshot();
		log.info(System.currentTimeMillis() + " - " + "Taking screenshots finished");

		// unmark target item
		if (type!=null&& type.equalsIgnoreCase("Radio")){
			_targetItems_rad.get(intendedTargetItemIndex).setBackground(targetItemColor);
		}
		else if (type!=null&& type.equalsIgnoreCase("Toggle")){
			_targetItems_toggle.get(intendedTargetItemIndex).setBackground(targetItemColor);
		}
		else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
			_targetItems_chk.get(intendedTargetItemIndex).setBackground(targetItemColor);
		}else{
		_targetItems.get(intendedTargetItemIndex).setBackground(targetItemColor);
		}

		// compute time needed to trigger button
		timeDuration = timeEnd - timeStart;

		log.info(System.currentTimeMillis() + " - " + "Start writing data to the XML element of current TestPlanItem");
		recordData(intendedTargetItemIndex,selectedTargetItemIndex,timeDuration,rawGPs,filteredGPs,this.rawGazeDataFuture,this.filteredGazeDataFuture);
		log.info(System.currentTimeMillis() + " - " + "Finished writing data to the XML element of current TestPlanItem");

		targetIndexCounter++;

		// notify GazeTargetOwner (TestManager), that the user performed the click and recording data is finished
		// because now, the owner can select the next intended target item
		// send recorded data to the GazeTarget owner too
		gazeTargetOwner.recordingDataInGazeTargetFinished(recordedData);
	}

	private void doSelection(JToggleButton jToggleButton) {
		// TODO Auto-generated method stub
		jToggleButton.doClick();
	}

	private void doSelection(JRadioButton jRadioButton) {
		// TODO Auto-generated method stub
		jRadioButton.doClick();
	}

	private void doSelection(JCheckBox jCheckBox) {
		// TODO Auto-generated method stub
jCheckBox.doClick();
	}

	/*
	 * (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#doSelection(javax.swing.JButton)
	 */
	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#doSelection(javax.swing.JButton)
	 */
	@Override
	protected void doSelection(JButton button) {
		// perform a "click" as visual feedback
		button.doClick();
	}
	//siby
	protected void doSelection_chkBox(JCheckBox chkbox) {
		// perform a "click" as visual feedback
		chkbox.doClick();
	}
	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#toXML()
	 */
	@Override
	protected Element toXML() {
		return null;
	}

	/**
	 * This method writes all recorded GazeData into an XML element.
	 * @param intendedTargetItemIndex
	 * @param selectedTargetItemIndex
	 * @param time
	 * @param rawGPs
	 * @param filteredGPs
	 * @param rawGazeDataFuture
	 * @param filteredGazeDataFuture
	 */
	protected void recordData(int intendedTargetItemIndex, int selectedTargetItemIndex, long time, ConcurrentLinkedDeque<GazePoint> rawGPs, ConcurrentLinkedDeque<GazePoint> filteredGPs, GazeDataFuture rawGazeDataFuture, GazeDataFuture filteredGazeDataFuture) {

		recordedData = new Element("ResultTarget").setAttribute("index", String.valueOf(targetIndexCounter));

		recordedData.addContent(new Element("IntendedTargetItemIndex").setText(String.valueOf(intendedTargetItemIndex)));
		recordedData.addContent(new Element("SelectedTargetItemIndex").setText(String.valueOf(selectedTargetItemIndex)));
		recordedData.addContent(new Element("TimeNeeded").setText(String.valueOf(time)));
		recordedData.addContent(new Element("TimeTickStart").setText(String.valueOf(timeTickStart)));
		recordedData.addContent(new Element("TimeTickTriggered").setText(String.valueOf(timeTickTriggered)));

		if (!rawGPs.isEmpty()) {
			Element rawGPsElement = new Element("RawGazePoints");
			Element gazePoint;
			Iterator<GazePoint> iter = rawGPs.iterator();
			GazePoint currentGP;
			while (iter.hasNext()) {
				currentGP = iter.next();
				gazePoint = new Element("GazePoint");
				gazePoint.addContent(new Element("X").setText(String.valueOf(currentGP.getLocation().x)))
				.addContent(new Element("Y").setText(String.valueOf(currentGP.getLocation().y)))
				.addContent(new Element("TimeTick").setText(String.valueOf(currentGP.getTimestamp())))
				.addContent(new Element("Validity").setText(String.valueOf(currentGP.getValidity().toString())));
				rawGPsElement.addContent(gazePoint);
			}		
			recordedData.addContent(rawGPsElement);
		}

		if (!filteredGPs.isEmpty()) {
			Element filteredGPsElement = new Element("FilteredGazePoints");
			Element gazePoint;
			Iterator<GazePoint> iter = filteredGPs.iterator();
			GazePoint currentGP;
			while (iter.hasNext()) {
				currentGP = iter.next();
				gazePoint = new Element("GazePoint");
				gazePoint.addContent(new Element("X").setText(String.valueOf(currentGP.getLocation().x)))
				.addContent(new Element("Y").setText(String.valueOf(currentGP.getLocation().y)))
				.addContent(new Element("TimeTick").setText(String.valueOf(currentGP.getTimestamp())))
				.addContent(new Element("Validity").setText(String.valueOf(currentGP.getValidity().toString())));
				filteredGPsElement.addContent(gazePoint);
			}		
			recordedData.addContent(filteredGPsElement);
		}

		if (rawGazeDataFuture != null && !rawGazeDataFuture.getFutureGazePoints().isEmpty()) {
			Element rawFutureGPsElement = new Element("RawFutureGazePoints");
			Element gazePoint;
			Iterator<GazePoint> iter = rawGazeDataFuture.getFutureGazePoints().iterator();
			GazePoint currentGP;
			while (iter.hasNext()) {
				currentGP = iter.next();
				gazePoint = new Element("GazePoint");
				gazePoint.addContent(new Element("X").setText(String.valueOf(currentGP.getLocation().x)))
				.addContent(new Element("Y").setText(String.valueOf(currentGP.getLocation().y)))
				.addContent(new Element("TimeTick").setText(String.valueOf(currentGP.getTimestamp())))
				.addContent(new Element("Validity").setText(String.valueOf(currentGP.getValidity().toString())));
				rawFutureGPsElement.addContent(gazePoint);
			}		
			recordedData.addContent(rawFutureGPsElement);
		}

		if (filteredGazeDataFuture!=null && !filteredGazeDataFuture.getFutureGazePoints().isEmpty()) {
			Element filteredFutureGPsElement = new Element("FilteredFutureGazePoints");
			Element gazePoint;
			Iterator<GazePoint> iter = filteredGazeDataFuture.getFutureGazePoints().iterator();
			GazePoint currentGP;
			while (iter.hasNext()) {
				currentGP = iter.next();
				gazePoint = new Element("GazePoint");
				gazePoint.addContent(new Element("X").setText(String.valueOf(currentGP.getLocation().x)))
				.addContent(new Element("Y").setText(String.valueOf(currentGP.getLocation().y)))
				.addContent(new Element("TimeTick").setText(String.valueOf(currentGP.getTimestamp())))
				.addContent(new Element("Validity").setText(String.valueOf(currentGP.getValidity().toString())));
				filteredFutureGPsElement.addContent(gazePoint);
			}		
			recordedData.addContent(filteredFutureGPsElement);
		}		
	}


	/*
	 * (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#setTargetIndex(int)
	 */
	@Override
	protected void setTargetIndex(int index) {

		if (rawGazeDataProvider!=null) {
			rawGazeDataProvider.addGazePointListener(this);
		}
		if (filteredDataProvider!=null) { 
			filteredDataProvider.addGazePointListener(this);
		}
		log.info(System.currentTimeMillis() + " - " + "Added GazeTargetPanel as GazePointListener to the GazeDataProvider");

		// reset gazePoint lists before new intended targetItem is marked
		_rawGazePoints.clear();
		_filteredGazePoints.clear();

		// set new intended TargetItem as selected
		intendedTargetItemIndex = index;
		if (type!=null&& type.equalsIgnoreCase("Radio")){
			_targetItems_rad.get(index).setBackground(targetItemSelectedColor);
		}
		else if (type!=null&& type.equalsIgnoreCase("Toggle")){
			_targetItems_toggle.get(index).setBackground(targetItemSelectedColor);
		}
		else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
			_targetItems_chk.get(index).setBackground(targetItemSelectedColor);

		}else{
		_targetItems.get(index).setBackground(targetItemSelectedColor);
		}
		log.info(System.currentTimeMillis() + " - " + "Set intended TargetItem as marked on the GUI");

		// register this SelectionTriggerMechanismListener at the SelectionTriggerMechanism		
		selectionTriggerMechanism.addSelectionTriggerMechanismListener(this);
		log.info(System.currentTimeMillis() + " - " + "Added GazeTargetPanel as SelectionTriggerMechanismListener to the SelectionTriggerMechanism");
		// activate the selectionTriggerMechanism
		selectionTriggerMechanism.setActivated();
		log.info(System.currentTimeMillis() + " - " + "Activated the SelectionTriggerMechanism");

		// start recording time
		timeStart = System.currentTimeMillis();
		timeTickStart = System.nanoTime();		
		log.info(System.currentTimeMillis() + " - " + "Started recording time");
	}

	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#targetRect()
	 */
	@Override
	protected Rectangle targetRect() {
		return null;
	}

	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#setPopupOwner()
	 */
	@Override
	protected void setPopupOwner() {
	}

	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#initLocation()
	 */
	@Override
	protected void initLocation() {
	}

	/* (non-Javadoc)
	 * @see gaze_selection_library.GazeTarget#takeScreenshot()
	 */
	@Override
	protected void takeScreenshot() {
		// create an image of the JPanel
		BufferedImage bufImage = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_RGB);
		Graphics g = bufImage.getGraphics();
		g.setColor(this.getBackground());
		g.fillRect(0, 0,  bufImage.getWidth(), bufImage.getHeight());        
		this.paint(g);
		//this.print(g); // no idea which function is better

		// store raw image without any added Gazepoints for later analysis
		File folder = new File("Recorded Data");
		folder.mkdir();

		File imageFile = new File("Recorded Data\\" + gazeTargetOwner.getParticipantID() + "-" + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()) + "-" + gazeTargetOwner.getTestPlanItemIndex() + "-" + targetIndexCounter + "-raw.jpeg");
		try{
			imageFile.createNewFile();
			ImageIO.write(bufImage, "jpeg", imageFile);
		}catch(Exception e){
			log.log(Level.SEVERE,null, e);
		}

		// add points for raw GPs before trigger, which were responsible for the recentLocation value
		g.setColor(Color.ORANGE);
		for (int i=0; i<_validGPbeforeTrigger.size();i++) {
			g.fillRoundRect(_validGPbeforeTrigger.get(i).getLocation().x-3, _validGPbeforeTrigger.get(i).getLocation().y-3, 6, 6,50,50);
		}

		// notify raw and filtered GazeDataReader to stop recording future gaze data. This is necessary to guarantee that the FutureGazePoint list will not
		// be updated while taking the screenshot or recording the data to a xml file
		if (rawGazeDataFuture!=null) {
			while (rawGazeDataFuture.getFutureGazePoints().size()<minimumNumberForFutureGazePoints) {
				// wait for future GazePoints
				try {
					Thread.sleep(trackerFrequency);
				} catch (InterruptedException e) {
					log.log(Level.SEVERE,null, e);
				}
			}
			rawGazeDataFuture.setIsListening(false);
			log.info(System.currentTimeMillis() + " - " + "Stopped FutureGazeReader in background thread");
		}
		if (filteredGazeDataFuture!=null) {
			while (filteredGazeDataFuture.getFutureGazePoints().size()<minimumNumberForFutureGazePoints) {
				// wait for future GazePoints
				try {
					Thread.sleep(trackerFrequency);
				} catch (InterruptedException e) {
					log.log(Level.SEVERE,null, e);
				}
			}
			filteredGazeDataFuture.setIsListening(false);
			log.info(System.currentTimeMillis() + " - " + "Stopped FutureGazeReader in background thread");
		}

		// add points for raw future GPs after trigger
		if (rawGazeDataFuture != null) {
			g.setColor(Color.GREEN);
			Iterator<GazePoint> iter = rawGazeDataFuture.getFutureGazePoints().iterator();
			GazePoint current;
			int counter = 0;
			while (iter.hasNext() && counter<maximumNumberForFutureGazePoints) {
				current = iter.next();
				// filter future GazePoints which are invalid or partially valid or located outside this panel before painting
				if (current.getLocation().x > 0 && current.getLocation().x <= this.getWidth() && current.getLocation().y > 0 && current.getLocation().y <= this.getHeight() && current.getValidity().equals(Validity.VALID)) {
					g.fillRoundRect(current.getLocation().x-3, current.getLocation().y-3, 6, 6,50,50);
				}
				counter++;
			}
		}

		// add points for filtered future GPs after trigger
		if (filteredGazeDataFuture != null) {
			g.setColor(Color.YELLOW);
			Iterator<GazePoint> iter = filteredGazeDataFuture.getFutureGazePoints().iterator();
			GazePoint current;
			int counter = 0;
			while (iter.hasNext() && counter<maximumNumberForFutureGazePoints) {
				current = iter.next();
				// filter future GazePoints which are invalid or partially valid or located outside this panel before painting
				if (current.getLocation().x > 0 && current.getLocation().x <= this.getWidth() && current.getLocation().y > 0 && current.getLocation().y <= this.getHeight() && current.getValidity().equals(Validity.VALID)) {
					g.fillRoundRect(current.getLocation().x-3, current.getLocation().y-3, 6, 6,50,50);
				}
				counter++;
			}
		}

		// add point for the recentLocation point
		g.setColor(Color.RED);
		g.fillRoundRect(recentLocation.x-3, recentLocation.y-3, 6, 6,50,50);

		imageFile = new File("Recorded Data\\" + gazeTargetOwner.getParticipantID() + "-" + new SimpleDateFormat("yyyyMMddHHmmss").format(new Date()) + "-" + gazeTargetOwner.getTestPlanItemIndex() + "-" + targetIndexCounter + ".jpeg");
		try{
			imageFile.createNewFile();
			ImageIO.write(bufImage, "jpeg", imageFile);
		}catch(Exception e){
			log.log(Level.SEVERE,null, e);
		}
	}

	/*
	 * (non-Javadoc)
	 * @see gaze_library.GazePointListener#gazePointHappened(gaze_library.GazePointEvent)
	 */
	@Override
	public void gazePointHappened(GazePointEvent gazePointEvent) {
		// add new GazePoint to queue and notify the gazePointReceivedThread
		concurrentGPEQueue.add(gazePointEvent);
		synchronized (gazePointReceivedThread) {
			gazePointReceivedThread.notify();
		}
	}

	/**
	 * This method processes the given GazePointEvent and paints a visual feedback cursor depending on the GazePoint.
	 * @param gazePointEvent
	 */
	void processReceivedGazePointEvent (GazePointEvent gazePointEvent) {

		// only if panel is displayed GazePointEvent is relevant
		if (this.isShowing()) {

			// create new GazePoint with updated location regarding to this jPanel
			// a copy is necessary because otherwise the updated location leads to an error in the DwellTimeTriggerMechanism
			int validity;
			switch (gazePointEvent.getGazePoint().getValidity()) {
			case PARTIALLY_VALID:
				validity = 1;
				break;
			case VALID:
				validity = 2;
				break;
			case INVALID:
				validity = 0;
				break;
			default:
				validity = 0;
				break;
			}
			GazePoint gazePoint;
			if (gazePointEvent.getGazePoint() instanceof GP3GazePoint) {
				gazePoint = new GP3GazePoint(gazePointEvent.getGazePoint().getLocation().x-this.getLocationOnScreen().x, gazePointEvent.getGazePoint().getLocation().y-this.getLocationOnScreen().y, validity, gazePointEvent.getGazePoint().getTimestamp());
			} else if (gazePointEvent.getGazePoint() instanceof TheEyeTribeGazePoint) {
				gazePoint = new TheEyeTribeGazePoint(gazePointEvent.getGazePoint().getLocation().x-this.getLocationOnScreen().x, gazePointEvent.getGazePoint().getLocation().y-this.getLocationOnScreen().y, validity, gazePointEvent.getGazePoint().getTimestamp());
			}else{
				gazePoint = new SimpleGazePoint(gazePointEvent.getGazePoint().getLocation().x-this.getLocationOnScreen().x, gazePointEvent.getGazePoint().getLocation().y-this.getLocationOnScreen().y, validity, gazePointEvent.getGazePoint().getTimestamp());

			}

			// stores valid and invalid GazePoints for the last 5 seconds
			if (_rawGazePoints.size() < 5*trackerFrequency) {
				_rawGazePoints.addFirst(gazePoint);
			}
			else {
				_rawGazePoints.removeLast();
				_rawGazePoints.addFirst(gazePoint);
			}

			// paint feedback cursor
			if (feedBackCursor) {
				// filter GazePoints which are invalid or partially valid or located outside this panel before painting cursor
				if (gazePoint.getLocation().x > 0 && gazePoint.getLocation().x <= this.getWidth() && gazePoint.getLocation().y > 0 && gazePoint.getLocation().y <= this.getHeight() && gazePoint.getValidity().equals(Validity.VALID)) {
					Graphics gr = this.getGraphics();
					// first GazePoint because lastGazePointLocation is null -> paint cursor
					if (lastGazePointLocation == null) {
						gr = this.getGraphics();
						// paint new cursor
						gr.setColor(Color.BLACK);
						gr.fillRoundRect(gazePoint.getLocation().x-3, gazePoint.getLocation().y-3, 6, 6,50,50);

						lastGazePointLocation = gazePoint.getLocation();

						// to avoid jittering check before painting cursor if new GazePoint location is equal to last GazePoint location
					} else if (lastGazePointLocation.x != gazePoint.getLocation().x || lastGazePointLocation.y != gazePoint.getLocation().y) {
						// overpaint old cursor
						gr.setColor(this.getBackground());
						gr.fillRoundRect(lastGazePointLocation.x-3, lastGazePointLocation.y-3, 6, 6,50,50);
						// paint new cursor
						gr.setColor(Color.BLACK);
						gr.fillRoundRect(gazePoint.getLocation().x-3, gazePoint.getLocation().y-3, 6, 6,50,50);

						lastGazePointLocation = gazePoint.getLocation();
					}
				}
			}
			
			// check if current gazepoint is located on a targetitem -> highlight as selected as visual feedback
			highlightTarget(gazePoint);
		}
	}
	
	/**
	 * This method checks if the given gazepoint is located on one of the targetitems. If this is the case, it is seleceted as visual feedback.
	 * @param gazePoint
	 */
	protected void highlightTarget(GazePoint gazePoint) {
		int currentTargetIndex = -1;

		// check if the given gazepoint locaction fits to one of the targetItems -> highlighting
		if (type!=null&& type.equalsIgnoreCase("Radio")){
			Iterator<JRadioButton> iter_rad = _targetItems_rad.iterator();

//int currentTargetIndex = -1;
for (int i=0; iter_rad.hasNext(); i++) {
	JRadioButton current = iter_rad.next();
	if (gazePoint.getLocation().x >= current.getLocation().x && gazePoint.getLocation().x <= current.getLocation().x + current.getWidth() && gazePoint.getLocation().y >= current.getLocation().y && gazePoint.getLocation().y <= current.getLocation().y + current.getHeight()) {
		currentTargetIndex = i;
		break;
	}
}

		}
		else if (type!=null&& type.equalsIgnoreCase("Toggle")){
			Iterator<JToggleButton> iter_togg = _targetItems_toggle.iterator();

//int currentTargetIndex = -1;
for (int i=0; iter_togg.hasNext(); i++) {
	JToggleButton current = iter_togg.next();
	if (gazePoint.getLocation().x >= current.getLocation().x && gazePoint.getLocation().x <= current.getLocation().x + current.getWidth() && gazePoint.getLocation().y >= current.getLocation().y && gazePoint.getLocation().y <= current.getLocation().y + current.getHeight()) {
		currentTargetIndex = i;
		break;
	}
}

		}
		else if (type!=null&& type.equalsIgnoreCase("Checkbox")){			
			Iterator<JCheckBox> iter_chk = _targetItems_chk.iterator();
			
			//int currentTargetIndex = -1;
			for (int i=0; iter_chk.hasNext(); i++) {
				JCheckBox current = iter_chk.next();
				if (gazePoint.getLocation().x >= current.getLocation().x && gazePoint.getLocation().x <= current.getLocation().x + current.getWidth() && gazePoint.getLocation().y >= current.getLocation().y && gazePoint.getLocation().y <= current.getLocation().y + current.getHeight()) {
					currentTargetIndex = i;
					break;
				}
			}

		}else{
		Iterator<JButton> iter = _targetItems.iterator();
		
		for (int i=0; iter.hasNext(); i++) {
			JButton current = iter.next();
			if (gazePoint.getLocation().x >= current.getLocation().x && gazePoint.getLocation().x <= current.getLocation().x + current.getWidth() && gazePoint.getLocation().y >= current.getLocation().y && gazePoint.getLocation().y <= current.getLocation().y + current.getHeight()) {
				currentTargetIndex = i;
				break;
			}
		}
		}
		// highlight target as feedback
		if (lastTargetIndex != -1) {
			if (lastTargetIndex != currentTargetIndex) {
				if (type!=null&& type.equalsIgnoreCase("Radio")){
					_targetItems_rad.get(lastTargetIndex).setSelected(false);
				}
				else if (type!=null&& type.equalsIgnoreCase("Toggle")){
					_targetItems_toggle.get(lastTargetIndex).setSelected(false);
				}
				else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
					_targetItems_chk.get(lastTargetIndex).setSelected(false);
				}else{
				_targetItems.get(lastTargetIndex).setSelected(false);
					}
			}
		}
		if (currentTargetIndex != -1) {
			if (lastTargetIndex != currentTargetIndex) {
				if (lastTargetIndex != currentTargetIndex) {
					if (type!=null&& type.equalsIgnoreCase("Radio")){
						_targetItems_rad.get(currentTargetIndex).setSelected(true);
					}
					else if (type!=null&& type.equalsIgnoreCase("Toggle")){
						_targetItems_toggle.get(currentTargetIndex).setSelected(true);
					}
					else if (type!=null&& type.equalsIgnoreCase("Checkbox")){
						_targetItems_chk.get(currentTargetIndex).setSelected(true);
					}
				}else{
				_targetItems.get(currentTargetIndex).setSelected(true);
				}
			}
		}
		lastTargetIndex = currentTargetIndex;
	}

	/*
	 * (non-Javadoc)
	 * @see gaze_selection_library.SelectionTriggerMechanismListener#triggerEventHappend()
	 */
	@Override
	public void triggered(TriggerEvent triggerEvent) {
		if (storeFutureGazeData) {			
			if (rawGazeDataFuture != null) {
				rawGazeDataFuture.setIsListening(true);
			}
			if (filteredGazeDataFuture != null) {
				filteredGazeDataFuture.setIsListening(true);
			}	
			log.info(System.currentTimeMillis() + " - " + "Started recording future gaze data");
		}
		synchronized (triggerThread) {
			triggerThread.notify();
		}		
	}

	/**
	 * This method is only needed for the SpeechTriggerMechanism to release the microphone.
	 * Because the start and stop of the microphone costs much time, it is only done after
	 * all targetItems on this BasicGazeTarget are selected.
	 */
	public void release() {
		if (selectionTriggerMechanism instanceof SpeechTriggerMechanism) {
			SpeechTriggerMechanism spm = (SpeechTriggerMechanism) selectionTriggerMechanism;
			spm.release();
		}
	}

}
